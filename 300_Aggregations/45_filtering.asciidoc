
== Filtering Queries and Aggregations

aggregation 범위 지정에 대한 자연스러운 확장은 필터링이다. aggregation은 query의 범위 내에서 동작하므로, query에 적용된 어떠한 filter도 aggregation에 적용된다.

[float="true"]
=== Filtered Query

$10,000 이상의 모든 자동차와 그 차들의 평균가를 계산하려면, 간단하게 `filtered` query를 사용할 수 있다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query" : {
        "filtered": {
            "filter": {
                "range": {
                    "price": {
                        "gte": 10000
                    }
                }
            }
        }
    },
    "aggs" : {
        "single_avg_price": {
            "avg" : { "field" : "price" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json

지난 장에서 설명한 것처럼, 기본적으로 `filtered` query를 사용하는 것은 `match` query를 사용하는 것과 차이가 없다. query(filter를 포함하는)는 document의 특정 부분집합을 반환하고, aggregation은 해당 document에 대해 동작한다.

[float="true"]
=== Filter Bucket

하지만 aggregation 결과를 필터링하고 싶다면 어떻게 해야할까? 자동차 대리점을 위한 검색 페이지를 구현한다고 가정해 보자. 사용자의 검색 내용에 따라 검색 결과를 표시해야 한다. 그러나 지난 달에 판매된 (검색에 일치하는) 자동차의 평균 가격을 포함하면, 페이지가 더 멋질 것이다.

두 가지의 다른 기준이 있기 때문에, 여기에서 단순한 범위 지정을 사용할 수 없다. 검색 결과는 +ford+에 일치해야 한다. 그러나 집계 결과는 +ford+ 그리고 +sold > now - 1M+에 일치해야 한다.

이 이슈를 해결하기 위해, filter라 불리는 특별한 bucket을 사용할 수 있다. filter를 지정하면, document가 filter의 기준에 일치하는 경우, 그들은 bucket에 추가된다.

아래가 그 query이다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
   "query":{
      "match": {
         "make": "ford"
      }
   },
   "aggs":{
      "recent_sales": {
         "filter": { <1>
            "range": {
               "sold": {
                  "from": "now-1M"
               }
            }
         },
         "aggs": {
            "average_price":{
               "avg": {
                  "field": "price" <2>
               }
            }
         }
      }
   }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
<1> filter를 적용하기 위해, `filter` bucket을 사용해 query 범위에 추가한다.
<2> `avg` metric은 +ford+이고 지난 달에 팔린 document들의 평균일 것이다.

`filter` bucket은 다른 bucket과 마찬가지로 동작하기 때문에, 다른 bucket이나 metric 내부에 중첩하는 것이 자유롭다. 모든 중첩된 요소는 filter를 "상속(inherit)"한다. 이는 필요에 따라 aggregation의 선택적인 부분을 필터링할 수 있다는 것을 의미한다.

[float="true"]
=== Post Filter

이제, 검색 결과와 aggregation 양쪽 모두를 필터링(`filtered` query)하고, aggregation의 개별 부분을 필터링 (`filtered` bucket)하는 방법을 알게 되었다.

“그럼, aggregation이 아니라 단지 검색 결과만 필터링하는 방법이 있을까?”라는 생각이 들것이다. 정답은 `post_filter`를 사용하는 것이다.

이것은 filter를 활용하는 최고 수준(top-level)의 검색 요청 요소이다. filter는 query가 실행된 이후에 적용된다. (query가 실행된 다음에 그것이 실행되기 때문에, +post+라는 이름으로 불린다.) query가 실행된 후에 그것이 동작하기 때문에, query의 범위에 영향을 미치지 않는다. 따라서, aggregation에도 영향을 미치지 않는다.

UI의 카테고리(categorical facets) 같은 것에 영향을 미치지 않고, 검색 기준에 추가 filter를 적용하여, 이 동작을 사용할 수 있다. 자동차 판매상을 위한 또 다른 검색 페이지를 계획해 보자. 이 페이지는 사용자가 자동차를 검색하고, 색상으로 필터링할 수 있다. 색상 선택은 aggregation으로 채워진다.

[source,js]
--------------------------------------------------
GET /cars/transactions/_search?search_type=count
{
    "query": {
        "match": {
            "make": "ford"
        }
    },
    "post_filter": {    <1>
        "term" : {
            "color" : "green"
        }
    },
    "aggs" : {
        "all_colors": {
            "terms" : { "field" : "color" }
        }
    }
}
--------------------------------------------------
// SENSE: 300_Aggregations/45_filtering.json
<1> `post_filter` 요소는 +최고 수준(top-level)+의 요소이고, 검색 조건에 일치하는 document(search hits)만을 필터링한다.

`query` 부분은 +ford+ 자동차를 찾는다. 그 다음에 terms aggregation으로 색상 목록을 만든다. aggregation은 query 범위에서 동작하기 때문에, 색상 목록은 Ford 자동차에 칠해진 색상에 부합할 것이다.

마지막으로, `post_filter`는 녹색 +ford+ 자동차만을 보여주기 위해 검색 결과를 필터링한다. 이것은 query가 실행된 후에 발생한다. 따라서 aggregation에는 영향을 미치지 않는다.

이것은 일관성 있는 UI에 있어 중요하다. 사용자가 UI에서 특정 카테고리(예: green)를 클릭한다고 가정해 보자. 기대하는 것은 검색 결과가 필터링 되는 것이지, UI의 옵션이 아니다. `filtered` query를 적용하게 되면, UI는 사용자가 원하는 바가 아닐지라도, 옵션처럼 +green+만을 보여주기 위해 즉시 변경될 것이다.

[WARNING]
.Performance consideration - 성능에 대한 고려
====
검색 결과와 aggregation을 따로 필터링해야 한다면, `post_filter`만 사용하자. 가끔 사람들은 일반 검색에 `post_filter`를 사용한다.

그렇게 하면 안된다. `post_filter`의 본질은 query 후에 그것을 실행하는 것이다. 그렇게 하면 필터링의 성능상 이점(cache 등)을 완전히 잃어버리게 된다.

`post_filter`는 aggregation과 조합해서만, 그리고 차별적인 필터링이 필요할 경우에만 사용되어야 한다.
====

[float="true"]
=== Recap

필터링의 적절한 type(검색 hits, aggregation 또는 둘 모두)을 선택하는 것은 사용자 인터페이스가 어떻게 동작해야 하는지에 따라 결정된다. 사용자에게 결과를 나타내는 방법에 따라, 적절한 filter나 조합을 선택하자.

 - `filtered` query는 검색 결과와 aggregation 모두에 영향을 미친다.
 - `filter` bucket은 집계에만 영향을 미친다.
 - `post_filter`는 검색 결과에만 영향을 미친다.
